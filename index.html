<!DOCTYPE html>
<html lang="en">

<head>
	<title>360&#176; viewer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
	<script defer src="vendor/fontawesome/all.min.js"></script>
</head>

<body>

	<script>
		function showHide() {
			let uriPanelComponent = document.getElementById('uriPanel');
			if (uriPanelComponent.classList.contains("d-none"))
			{
				uriPanelComponent.classList.remove("d-none");
				document.getElementById('button-apply').classList.remove("d-none");
			}
			else
			{
				uriPanelComponent.classList.add("d-none");
				document.getElementById('button-apply').classList.add("d-none");
			}
			return false;
		}
	</script>

	<div id="container" style="position: absolute; left:0px; top:0px"></div>
	<div id="info" style="position: absolute; left:0px; top:0px">
		<div class="input-group mb-3">
			<button class="btn btn-primary" type="button" id="button-showhide" onclick="return showHide();" title="Open/Close image URL panel"><i class="fas fa-image"></i></button>
			<form class="form-floating d-none" style="vertical-align: middle; text-align: center; width:80vw"
				id="uriPanel">
				<input type="url" class="form-control" id="textureUri" placeholder="texture URI"
					value="images/Deep Rock Galactic 360 2020.12.19 - 21.34.03.75.jpg">
				<label for="floatingInputValue">Enter location of panorama 360&#176; image:</label>
			</form>
			<button class="btn btn-primary d-none" type="button" id="button-apply">Apply</button>
		</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>

	<script type="module">

		import * as THREE from 'https://unpkg.com/three@0.123.0/build/three.module.js';

		let camera, scene, renderer, texture;

		let isUserInteracting = false,
			onPointerDownMouseX = 0, onPointerDownMouseY = 0,
			lon = 0, onPointerDownLon = 0,
			lat = 0, onPointerDownLat = 0,
			phi = 0, theta = 0;

		init();
		animate();

		function loadTexture(textureUri) {
			const myimage = new Image();

			myimage.onload = () => {
				texture.image = myimage;
				texture.needsUpdate = true;
			};
			myimage.onerror = (err) => {
				//reject(myimage);
				alert(err);
			};
			myimage.onabort = (msg) => {
				//	reject(myimage);
				alert(msg);
			};
			myimage.crossOrigin = "anonymous";
			myimage.src = textureUri;
		}

		function apply() {
			isUserInteracting = false;
			const textureUriInput = document.getElementById('textureUri');
			loadTexture(textureUriInput.value);
			return false;
		}

		function init() {

			const container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

			scene = new THREE.Scene();

			const geometry = new THREE.SphereBufferGeometry(500, 60, 40);
			// invert the geometry on the x-axis so that all of the faces point inward
			geometry.scale(- 1, 1, 1);

			texture = new THREE.Texture();

			document.getElementById('button-apply').addEventListener('click', apply);
			apply();

			const material = new THREE.MeshBasicMaterial({ map: texture });

			const mesh = new THREE.Mesh(geometry, material);

			scene.add(mesh);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			container.style.touchAction = 'none';
			container.addEventListener('pointerdown', onPointerDown, false);

			document.addEventListener('wheel', onDocumentMouseWheel, false);

			//

			document.addEventListener('dragover', function (event) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			}, false);

			document.addEventListener('dragenter', function () {

				document.body.style.opacity = 0.5;

			}, false);

			document.addEventListener('dragleave', function () {

				document.body.style.opacity = 1;

			}, false);

			document.addEventListener('drop', function (event) {

				event.preventDefault();

				const reader = new FileReader();
				reader.addEventListener('load', function (event) {

					material.map.image.src = event.target.result;
					material.map.needsUpdate = true;

				}, false);
				reader.readAsDataURL(event.dataTransfer.files[0]);

				document.body.style.opacity = 1;

			}, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onPointerDown(event) {

			if (event.isPrimary === false) return;

			isUserInteracting = true;

			onPointerDownMouseX = event.clientX;
			onPointerDownMouseY = event.clientY;

			onPointerDownLon = lon;
			onPointerDownLat = lat;

			document.addEventListener('pointermove', onPointerMove, false);
			document.addEventListener('pointerup', onPointerUp, false);

		}

		function onPointerMove(event) {

			if (event.isPrimary === false) return;

			lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
			lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;

		}

		function onPointerUp() {

			if (event.isPrimary === false) return;

			//isUserInteracting = false;

			document.removeEventListener('pointermove', onPointerMove);
			document.removeEventListener('pointerup', onPointerUp);

		}

		function onDocumentMouseWheel(event) {

			const fov = camera.fov + event.deltaY * 0.05;

			camera.fov = THREE.MathUtils.clamp(fov, 10, 75);

			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame(animate);
			update();

		}

		function update() {

			if (isUserInteracting === false) {

				lon += 0.1;

			}

			lat = Math.max(- 85, Math.min(85, lat));
			phi = THREE.MathUtils.degToRad(90 - lat);
			theta = THREE.MathUtils.degToRad(lon);

			const x = 500 * Math.sin(phi) * Math.cos(theta);
			const y = 500 * Math.cos(phi);
			const z = 500 * Math.sin(phi) * Math.sin(theta);

			camera.lookAt(x, y, z);

			renderer.render(scene, camera);

		}

	</script>
</body>

</html>